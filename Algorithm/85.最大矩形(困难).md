```text
题目: 给定一个仅包含0和1的二维二进制矩阵,找出只包含1的最大矩形,并返回其面积
    输入:
        [
          ["1","0","1","0","0"],
          ["1","0","1","1","1"],
          ["1","1","1","1","1"],
          ["1","0","0","1","0"]
        ]
    输出: 6
1.柱状图-动态规划:
    [1]思路: 
        (1)遍历输入矩形的每个位置,并重新构建该矩形: 每个位置上的值表示从左到该位置连续为"1"的个数
        (2)重构矩形时的状态转移方程: dp[i][j]=dp[i][j-1]+1 (j=1),dp[i][j]=1 (j=0)
            i: 行数; j: 列数; 即当遍历到的位置上值为1时,计算从该位置往左有多少个连续且值都为1的位置
        (3)从当前遍历到的位置向上移动,每移动一层,计算一个面积并取最大面积
    [2]实现:
        class Solution {    
            public int maximalRectangle(char[][] matrix) {
                // 定义一个变量保存行数
                int n = matrix.length;
                if (n == 0) {
                    return 0;
                }
                // 定义一个变量保存列数
                int m = matrix[0].length;
                // 定义一个变量保存最大面积
                int maxArea = 0;
                // 定义一个二维数组用来保存重构后的完整矩形
                int[][] dp = new int[n][m];
                // 遍历行
                for (int i = 0; i < n; i++) {
                    // 遍历列
                    for (int j = 0; j < m; j++) {
                        // 当前位置值为1,则重构其值,否则默认为0
                        if (matrix[i][j] == '1') {
                            // 为重构后的矩阵赋值(依据状态转移方程)
                            dp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;
                            // 定义一个变量用来保存之后想上移动过程中的最小宽度
                            int minWidth = dp[i][j];
                            // 从当前位置向上移动,每移动一层求面积再取最大面积
                            for (int k = i; k >= 0; k--) {
                                minWidth = Math.min(minWidth, dp[k][j]);
                                maxArea = Math.max(maxArea, minWidth * (i - k + 1));
                            }
                        }
                    }
                }
                return maxArea;
            }
        }
    [3]复杂度分析:
        (1)时间复杂度: O(M*N^2)
            正常遍历完整个矩形是O(NM),再加上每个位置上移是O(N),所以总共是O(N)*O(N*M)=O(M*N^2)
        (2)空间复杂度: O(N*M)
```