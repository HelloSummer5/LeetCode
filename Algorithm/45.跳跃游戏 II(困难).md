```text
题目: 从一个非负整数数组的第一个位置开始,数组中的每个元素代表在该位置可以跳跃的最大长度,使用最少的跳跃次数到达数组的最后一个位置;
    输入: [2,3,1,1,4]
    输出: 2
    解释: 跳到最后一个位置的最小跳跃数是2,从下标为0跳到下标为1的位置,跳1步,然后跳3步到达数组的最后一个位置;
说明: 假设总是可以到达数组的最后一个位置
1.正向查找可到达的最大位置(贪心算法)
    [1]思路: 
        (1)在每次跳跃范围之内,比较下次跳跃的最远距离(贪心)
        (2)遍历到了边界后就可确定跳哪个位置,同时可确定下次比较的边界;
    [2]实现:
        public int jump(int[] nums) {
            // 计算数组长度
            int length = nums.length;
            // 定义一个变量用来保存下一步可以跳的最远的位置
            int maxPosition = 0;
            // 定义一个变量用来保存所走的步数
            int step = 0;
            // 定义一个变量用来保存比较的边界
            int end = 0;
            for (int i = 0; i < length - 1; i++) {
                // 在一次可跳跃的范围之内获取下次可跳跃的最远位置
                maxPosition = Math.max(maxPosition, i + nums[i]);
                // 遍历到边界,最远跳跃位置就可确定,同时该最远跳跃位置就成了下次比较的边界
                if(i == end){
                    end = maxPosition;
                    step++;
                }
            }
            return step;
        }
    [3]复杂度分析:
        (1)时间复杂度: O(n),其中 n 是数组长度;
        (2)空间复杂度: O(1)
```